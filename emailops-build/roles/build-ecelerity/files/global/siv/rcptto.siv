### Receipt to Phase ###

# Include client variables
ec_include "/opt/msys/ecelerity/etc/conf/default/siv/client_vars.siv";

$recipient = envelope :all "to";
$sender = envelope "from";
$rcpt_domain = envelope :domain "to";
$rcpt_localpart = envelope :localpart "to";

# As_logger includes
ec_include "/opt/msys/ecelerity/etc/conf/global/siv/in_def_audit_series.siv";
ec_include "/opt/msys/ecelerity/etc/conf/global/siv/out_def_audit_series.siv";

if not vctx :is "as_wl" "true" {
    if vctx :is "mx" "true" {
        audit_series_add $ib_recipients_vol;
    }
    else {
        audit_series_add $ob_recipients_vol;
    }
}

# relay domain check  
($relay) = ds_fetch "relays" "SELECT address from inbound_relays where address like ?" ["%{vctx_mess:rcptto_domain}"];
if ec_test :contains $relay "" {
    vctx_mess_set "domain_allow_list" "yes";
}

# rcptto whitelist check
($rcptto_wl) = ds_fetch "wlbl" "SELECT address from ec_rcptto_wl_addresses where address = ?" ["%{vctx_mess:rcptto_localpart}@%{vctx_mess:rcptto_domain}"];
if ec_test :is :comparator "i;ascii-casemap" "${rcptto_wl}" "%{vctx_mess:rcptto_localpart}@%{vctx_mess:rcptto_domain}" {
    vctx_mess_set "rcptto_wl" "yes";
}

# RCPTTO Validation
# Validates recipients in LDAP domains.
# only validate recipients for the domains listed
# LDAP checks for sender.  If send is from one one of the local
# domains, then check to see if the sender really exists
# create a hash of values to send into the ldap string
$params_user = hash_create;
hash_set $params_user "to" $recipient;
hash_set $params_user "user" $rcpt_localpart;
hash_set $params_user "domain" $rcpt_domain;
hash_set $params_user "ldap_pw" $ldap_pass;

# Rcptto LDAP query
$results_domain = ds_fetch_hash "domain_check" "ldap:///?zimbraDomainName?sub?(&(zimbraDomainName=$domain)(zimbraDomainType=*)(zimbraMailStatus=enabled))?x-ldap-version=3,bindname=uid=zimbra%2ccn=admins%2ccn=zimbra,x-bindpw=$ldap_pw" $params_user;

# all domains that exist in ldap have one of three attributes:
# zimbraMailDeliveryAddress
# zimbraMailAlias
# zimbraMailCatchAllAddress
# and all must have zimbraMailStatus set to "enabled"

# set local_domain context to "no" to make sure
# no other domains ride along when doing multiple
# rcpt tos.
vctx_mess_set "local_domain" "no";

if isset $results_domain "zimbraDomainName" {
    # now check to see if user is in a domain
    $results_user = ds_fetch_hash "user_check" "ldap:///?zimbraPrefMailForwardingAddress,zimbraMailDeliveryAddress,zimbraMailHost,zimbraMailAlias,zimbraMailCatchAllAddress,amavisWhitelistSender,amavisBlacklistSender?sub?(&(|(|(zimbraMailDeliveryAddress=$to)(zimbraMailAlias=$to))(zimbraMailCatchAllAddress=@$domain))(zimbraMailStatus=enabled))?x-ldap-version=3,bindname=uid=zimbra%2ccn=admins%2ccn=zimbra,x-bindpw=$ldap_pw" $params_user;
    if anyof (isset $results_user "zimbraMailDeliveryAddress", isset $results_user "zimbraMailAlias", isset $results_user "zimbraMailCatchAllAddress") {
	    vctx_mess_set "local_domain" "yes";  	
	}
	else {
        if vctx_conn :is "mx" "true" {
            vctx_mess_set "premigration" "yes";
            vctx_mess_set "local_domain" "yes";
            ## new way - place ips with mask into cidr list
            #define_cidr "dha_wl" "wlbl" "select address || '/' || ifnull(netmask, 32) from ec_harvest_wl_ips" "600";
            # check to see if connecting IP is in cidrs listed
            #$is_dha_wl = check_cidr "dha_wl";
            #if not ec_test :is "${is_dha_wl}" "true" {
            #    ### Anti-DHA policy
            #    $failed_rcpttos = audit_series "failed_rcpttos" "60,1" "32";
            #    if ec_test :value "ge" :comparator "i;ascii-numeric" "${failed_rcpttos}" "${dha}" {
            #        if not ec_test :is "${as_wl}" "true" {
            #            audit_series_add $ib_rejections;
            #            audit_series_add $ib_recipient_violations;
            #        }
            #        ec_disconnect 550 "5.7.1 [R1] Too many invalid rcpts." "DHA:DHA Attempts:MX";
            #    }
            #}
            #else {
            #    # setting the dhawl context just as an fyi
            #    vctx_conn_set "dhawl" "yes";
            #    ec_inc_counter "DHA Whitelist:DHA Whitelist";
            #}    
            ## The directory harvest counter
            #    audit_series_add "failed_rcpttos" "60,1" "1";
            #    if not ec_test :is "${as_wl}" "true" {
            #    audit_series_add $ib_rejections;
            #    audit_series_add $ib_invalid_recipients_vol;
            #}
            #if anyof (ec_test :is $rcpt_domain "6newslawrence.com", ec_test :is $rcpt_domain "freestatestudios.com") {
            #    vctx_mess_set "nonzim" "yes";
            #}
            #else {
		#vctx_mess_set "missing" "yes";
                ##ec_inc_counter "stats:Invalid recipient:MX";
                ##ec_action 550 "5.1.1 [R2] Recipient ${recipient} does not exist here."  "Recipient rejected:MX Invalid recipient";
            #}
        }
            
        else {
            vctx_mess_set "premigration" "yes";
            vctx_mess_set "local_domain" "yes";
            ## new way - place ips with mask into cidr list
            #define_cidr "dha_wl" "wlbl" "select address || '/' || ifnull(netmask, 32) from ec_harvest_wl_ips" "600";
            ## check to see if connecting IP is in cidrs listed
            #$is_dha_wl = check_cidr "dha_wl";
            #if not ec_test :is "${is_dha_wl}" "true" {
            #    ### Anti-DHA policy
            #    $failed_rcpttos = audit_series "failed_rcpttos" "60,1" "32";
            #    if ec_test :value "ge" :comparator "i;ascii-numeric" "${failed_rcpttos}" "${dha}" {
            #        if not ec_test :is "${as_wl}" "true" {
            #            audit_series_add $ob_rejections;
            #            audit_series_add $ob_recipient_violations;
            #        }
            #        ec_disconnect 550 "5.7.1 [R3] Too many invalid rcpts." "DHA:DHA Attempts:SMTP";
            #    }
            #}
            #else {
            #    # setting the dhawl context just as an fyi
            #    vctx_conn_set "dhawl" "yes";
            #    ec_inc_counter "DHA Whitelist:DHA Whitelist";
            #}
            # The directory harvest counter
            #audit_series_add "failed_rcpttos" "60,1" "1";
            #if not ec_test :is "${as_wl}" "true" {
            #    audit_series_add $ob_rejections;
            #    audit_series_add $ob_invalid_recipients_vol;
            #}
            #if anyof (ec_test :is $rcpt_domain "6newslawrence.com", ec_test :is $rcpt_domain "freestatestudios.com") {
            #    vctx_mess_set "nonzim" "yes";
            #}
            #else {
	    #	vctx_mess_set "missing" "yes";
            #    #ec_inc_counter "stats:Invalid recipient:SMTP";
            #    #ec_action 550 "5.1.1 [R4] Recipient ${recipient} does not exist here."  "Recipient rejected:SMTP Invalid recipient";
            #}
        }
    }
}

# Check User Whitelist and Blacklists
if not ec_test :is "%{vctx_mess:mailfrom_localpart}@%{vctx_mess:mailfrom_domain}" "@" {
    if isset $results_user "amavisBlacklistSender" {
        $results_user_bl = $results_user["amavisBlacklistSender"];
        if type :is  $results_user_bl "stringlist" {
            $user_bl = join "," $results_user_bl;
            $user_bl1 = ",${user_bl}";
            if ec_test :matches :comparator "i;ascii-casemap" "${user_bl1}" [",%{vctx_mess:mailfrom_domain}"] {
                if not ec_test :is "${as_wl}" "true" {
                    if vctx_conn :is "mx" "true" {
                        audit_series_add $ib_rejections;
                        audit_series_add $ib_recipient_violations;
                    }
                    else {
                        audit_series_add $ob_rejections;
                        audit_series_add $ob_recipient_violations;
                    }
                }
                ec_action 550 "5.7.1 [R5] Mail rejected by policy.  (Blacklisted by user)" "policy:user blacklist";
            }
            else {
                if not ec_test :is "${as_wl}" "true" {        
                    if vctx_conn :is "mx" "true" {
                        audit_series_add $ib_rejections;
                        audit_series_add $ib_recipient_violations;
                    }
                    else {
                        audit_series_add $ob_rejections;
                        audit_series_add $ob_recipient_violations;
                    }
                }
                if ec_test :matches :comparator "i;ascii-casemap" "${user_bl1}" [",%{vctx_mess:mailfrom_localpart}@%{vctx_mess:mailfrom_domain}"] {
                    ec_action 550 "5.7.1 [R6] Mail rejected by policy.  (Blacklisted by user)" "policy:user blacklist";
                }
            }    
        }
        else {
            if not ec_test :contains :comparator "i;ascii-casemap" "${results_user_bl}" ["@%{vctx_mess:mailfrom_domain}"] {
                if ec_test :is :comparator "i;ascii-casemap" "${results_user_bl}" ["%{vctx_mess:mailfrom_domain}"] {
                    if not ec_test :is "${as_wl}" "true" {
                        if vctx_conn :is "mx" "true" {
                            audit_series_add $ib_rejections;
                            audit_series_add $ib_recipient_violations;
                        }
                        else {
                            audit_series_add $ob_rejections;
                            audit_series_add $ob_recipient_violations;
                        }
                    }
                    ec_action 550 "5.7.1 [R5] Mail rejected by policy.  (Blacklisted by user)" "policy:user blacklist";
                }
            }
            else {        
                if ec_test :is :comparator "i;ascii-casemap" "${results_user_bl}" ["%{vctx_mess:mailfrom_localpart}@%{vctx_mess:mailfrom_domain}"] {
                    if not ec_test :is "${as_wl}" "true" {
                        if vctx_conn :is "mx" "true" {
                            audit_series_add $ib_rejections;
                            audit_series_add $ib_recipient_violations;
                        }
                        else {
                            audit_series_add $ob_rejections;
                            audit_series_add $ob_recipient_violations;
                        }
                    }
                    ec_action 550 "5.7.1 [R6] Mail rejected by policy.  (Blacklisted by user)" "policy:user blacklist";
                }
            }    
        }                 
    } 
    if isset $results_user "amavisWhitelistSender" {
        $results_user_wl = $results_user["amavisWhitelistSender"];
        if type :is  $results_user_wl "stringlist" {
            $user_wl = join "," $results_user_wl;
            $user_wl1 = ",${user_wl}";
            if ec_test :regex :comparator "i;ascii-casemap" "${user_wl1}" [",%{vctx_mess:mailfrom_domain}"] {
                vctx_mess_set "user_wl" "yes";
            }
            else {
                if ec_test :matches :comparator "i;ascii-casemap" "${user_wl1}" [",%{vctx_mess:mailfrom_localpart}@%{vctx_mess:mailfrom_domain}"] {
                    vctx_mess_set "user_wl" "yes";
                }
            }                
        }
        else {
            if not ec_test :matches :comparator "i;ascii-casemap" "${results_user_wl}" ["@%{vctx_mess:mailfrom_domain}"] {
                if ec_test :is :comparator "i;ascii-casemap" "${results_user_wl}" ["%{vctx_mess:mailfrom_domain}"] {
                    vctx_mess_set "user_wl" "yes";
                }
            }
            else {         
                if ec_test :is :comparator "i;ascii-casemap" "${results_user_wl}" ["%{vctx_mess:mailfrom_localpart}@%{vctx_mess:mailfrom_domain}"] {
                    vctx_mess_set "user_wl" "yes";
                }
            }    
        }        
    }    
}

# if we are allowed by IP, or if we were present in 
# inbound_relays then accept the mail
if vctx_conn :is "mx" "true" {
	# server being used as mx server
	if anyof (vctx :is "local_domain" "yes", ec_test :contains $relay "" )  {
		ec_action 250 "2.1.5 Accepted for you" "Domain Accepted:Domain allowed";
		stop;
	} 
	else {
        if not ec_test :is "${as_wl}" "true" {
            audit_series_add $ib_rejections;
            audit_series_add $ib_recipient_violations;
        }
	    ec_action 554 "5.1.2 [R7] Domain Relaying denied." "Domain Rejected:Domain denied";
	}
}
else { 
	# server being used as smtp relay
    ($domain_exception) = ds_fetch "relays" "SELECT 1 from local_domain_exception where domain = lower(?) " ["%{vctx_mess:rcptto_domain}"];
    if ec_test :is "${domain_exception}" "1" {
        vctx_mess_set "local_domain_exception" "true";
    }
	if anyof(vctx_conn :is "ip_allow_list" "yes", vctx :is "auth_status" "pass", vctx_conn :is "trusted" "yes", vctx :is "local_domain_exception" "true", vctx_conn :is "dp_can_relay" "true" ) {
            # New limits logging
            if anyof (vctx_mess :is "biz_user" "yes", vctx_conn :is "biz_ip" "yes") {
                if vctx_conn :is "auth_status" "pass" {
			        if vctx :value "gt" :comparator "i;ascii-numeric" "message_rcpt_count" "${max_biz_log_rcptto}" {
                        ec_log_file "/var/log/ecelerity/logging.ec" "%{t} %{spfv1:i} ${sender} - Biz user exceeded rcpt to limit ${max_biz_log_rcptto}";
                        ec_log_file "jlog:///var/log/ecelerity/logging.cluster=>master" "%{t} %{spfv1:i} ${sender} - Biz user exceeded rcpt to limit ${max_biz_log_rcptto}";
                    }
                }
                else {    
			        if vctx :value "gt" :comparator "i;ascii-numeric" "message_rcpt_count" "${max_log_rcptto}" {
                        ec_log_file "/var/log/ecelerity/logging.ec" "%{t} %{spfv1:i} ${sender} - No auth biz user exceeded rcpt to limit ${max_log_rcptto}";
                        ec_log_file "jlog:///var/log/ecelerity/logging.cluster=>master" "%{t} %{spfv1:i} ${sender} - No auth biz user exceeded rcpt to limit ${max_log_rcptto}";
                    }
                }    
            }
            else {
			    if vctx :value "gt" :comparator "i;ascii-numeric" "message_rcpt_count" "${max_log_rcptto}" {
                    ec_log_file "/var/log/ecelerity/logging.ec" "%{t} %{spfv1:i} ${sender} - exceeded rcpt to limit ${max_log_rcptto}";
                    ec_log_file "jlog:///var/log/ecelerity/logging.cluster=>master" "%{t} %{spfv1:i} ${sender} - exceeded rcpt to limit ${max_log_rcptto}";
                }
            }
            # Rcptto Limits
            if anyof (vctx_mess :is "biz_user" "yes", vctx_conn :is "biz_ip" "yes") {
                if vctx_conn :is "auth_status" "pass" {
                    if vctx :value "gt" :comparator "i;ascii-numeric" "message_rcpt_count" "${max_biz_rcptto}" {
        	            vctx_mess_set "too_many_rcpttos" "yes";
				        if vctx :is "alerted" "yes" {
				        }
				        else {
		 			        vctx_mess_set "alerted" "yes";
				        }
                    }
                }    
                else {
                    if vctx :value "gt" :comparator "i;ascii-numeric" "message_rcpt_count" "${max_rcptto}" {
        	            vctx_mess_set "too_many_rcpttos" "yes";
				        if vctx :is "alerted" "yes" {
				        }
				        else {
		 			        vctx_mess_set "alerted" "yes";
				        }
                    }
                }
            }    
            else {                        
			    if vctx :value "gt" :comparator "i;ascii-numeric" "message_rcpt_count" "${max_rcptto}" {
        	        vctx_mess_set "too_many_rcpttos" "yes";
				    if vctx :is "alerted" "yes" {
				    }
				    else {
		 			    vctx_mess_set "alerted" "yes";
				    }
			    }
		    }
		ec_action 250 "2.1.5 Accepted for you" "Domain Accepted:Domain allowed";
		stop;
	} 
	else {
        if not ec_test :is "${as_wl}" "true" {
            audit_series_add $ob_rejections;
            audit_series_add $ob_session_violations;
        }
		ec_action 554 "5.7.1 [R8] Authentication Failed, must login." "Domain Rejected:Domain denied";
	}
}
