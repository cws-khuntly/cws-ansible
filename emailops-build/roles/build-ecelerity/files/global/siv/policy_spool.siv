### Policy Phase ###

# Clear out values from possible previous iterations:
vctx_mess_delete "premigration";
vctx_mess_delete "maildrop";

$recipient = envelope :all "to";
$sender = envelope "from";
$rcpt_domain = envelope :domain "to";
$rcpt_localpart = envelope :localpart "to";
$from_domain = envelope :domain "from";
$from_localpart = envelope :localpart "from";

# Include client variables
ec_include "/opt/msys/ecelerity/etc/conf/default/siv/client_vars.siv";

# Include Audit Series
ec_include "/opt/msys/ecelerity/etc/conf/global/siv/in_def_audit_series.siv";
ec_include "/opt/msys/ecelerity/etc/conf/global/siv/out_def_audit_series.siv";

# Add Auth headers for trackability
if vctx_conn :is "smtp_relay" "true" {
	if vctx_conn :contains "auth_user" "" {
		# The auth_user key is set in the connection context
		# so place it in a header: X-Authed-Username
		($local_part, $domain) = split "@" "%{vctx_conn:auth_user}";
		if ec_test :contains "${domain}" "" {	
			$listener_domain = vctx_conn_get "listener_domain";
			$auth_ident = ec_base64_encode "${local_part}@${listener_domain}";
		}
		else {
			$auth_ident = ec_base64_encode "${local_part}@${domain}";
		}
		ec_header_add "X-Authed-Username" "${auth_ident}";
	}
	else {
		$auth_ident = ec_base64_encode "${from_localpart}@${from_domain}";
		ec_header_add "X-Authed-Username" "${auth_ident}";
	}
}

# Webmail RBL Checks

# Check to see if message is outbound mail.
if vctx_conn :is "trusted" "yes" {
	if exists "X-Originating-IP" {
		# Grab the X-Originating IP and split to create the RBL lookups.
        $orig_ip = ec_header_get "X-Originating-IP";
        vctx_mess_set "webmail_ip" "${orig_ip}";
        ($front, $mid) = split "[" "${orig_ip}";
        ($ip, $back) = split "]" "${mid}";
        ($a, $b, $c, $d) = split "." "${ip}";
		# Synbl Check 
        vctx_mess_set "synbl_lookup_string" "${d}.${c}.${b}.${a}.synbl";
		($synbl) = ec_dns_lookup "${d}.${c}.${b}.${a}.synbl" "a";
        if ec_test :is "${synbl}" ["127.0.0.2"] {
		    $response = ec_dns_lookup "${d}.${c}.${b}.${a}.synbl" "txt";                         
            $md_bind = vctx_conn_get "ehlo_domain";
			$mf_local = vctx_mess_get "mailfrom_localpart";
            $mf_domain = vctx_mess_get "mailfrom_domain";
        	ec_gauge_cache_init "sbl_list" 25000 1800;
        	$on_sbl = ec_gauge_cache_get "sbl_list" "${sender}";

			# Send a copy of the message if we haven't in the last 30 minutes
        	if ec_test :value "lt" :comparator "i;ascii-numeric" "${on_sbl}" "1" {
	        	$to = "${postmaster}";
	        	$from = "${mailer_daemon}";

# Generate bonce message for webmail users. NOTE: generate_mail_raw does not like tabbed spacing 
generate_mail_raw $from $to text:
From: ${from}
To: ${to}
Subject: Synacor Black List Block on webmail user ${sender}

${sender} has tried to send email, but was blocked due to being on synbl:
${d}.${c}.${b}.${a}.synbl

%{rfc2822:message}
.
;

				ec_gauge_cache_inc "sbl_list" "${sender}";
			}

			# Send a bounced message to the webmail user
			if vctx_conn :contains "ehlo_domain" ".${cluster}" {
            	vctx_mess_set "maildrop" "${md_bind}";
				$from = "${mailer_daemon}";
            	$to = "${mf_local}@${mf_domain}";

# Generate bonce message for webmail users. NOTE: generate_mail_raw does not like tabbed spacing  
generate_mail_raw $from $to text:
From: ${from}
To: ${to}
X-BINDING: ${md_bind}
Subject: 550 5.7.1 [P1] RBL Restriction: Blacklisted by Internal Reputation Service - ${orig_ip}

Blacklisted by Internal Reputation Service.

%{rfc2822:message}
.
;

                vctx_mess_set "xbl_xorg_responce" "${response}";
                ec_discard "RBL:SYNBL:XORIG";
                stop;
        	}
		}

		# Spamhaus Check
        vctx_mess_set "rbl_lookup_string" "${d}.${c}.${b}.${a}.zen.spamhaus.org";
        #$zen = ec_dns_lookup "${d}.${c}.${b}.${a}.zen.spamhaus.org" "a";
		$result = ec_dns_lookup "${d}.${c}.${b}.${a}.zen.spamhaus.org" "a";
		$zen = join "," $result;
		if ec_test :contains "${zen}" ["127.0.0.2", "127.0.0.3", "127.0.0.5"] {
            $response = ec_dns_lookup "${d}.${c}.${b}.${a}.zen.spamhaus.org" "txt";
        	$md_bind = vctx_conn_get "ehlo_domain";
            $mf_local = vctx_mess_get "mailfrom_localpart";
            $mf_domain = vctx_mess_get "mailfrom_domain";
			ec_gauge_cache_init "sbl_list" 25000 1800;
        	$on_sbl = ec_gauge_cache_get "sbl_list" "${sender}";
	
			# Send a copy of the message if we haven't in the last 30 minutes
        	if ec_test :value "lt" :comparator "i;ascii-numeric" "${on_sbl}" "1" {
				$to = "${postmaster}";
        		$from = "${mailer_daemon}";
        
# Generate bonce message for webmail users. NOTE: generate_mail_raw does not like tabbed spacing 
generate_mail_raw $from $to text:
From: ${from}
To: ${to}
Subject: SBL/XBL Block on webmail user ${sender}

${sender} has tried to send email, but was blocked due to being on sbl:
${d}.${c}.${b}.${a}.zen.spamhaus.org

%{rfc2822:message}
.
;
        		ec_gauge_cache_inc "sbl_list" "${sender}";
			}

			# Send a bounced message to the webmail user
			if vctx_conn :contains "ehlo_domain" ".${cluster}" {
				vctx_mess_set "maildrop" "${md_bind}";
            	$from = "${mailer_daemon}";
            	$to = "${mf_local}@${mf_domain}";

# Generate bonce message for webmail users. NOTE: generate_mail_raw does not like tabbed spacing  
generate_mail_raw $from $to text:
From: ${from}
To: ${to}
X-BINDING: ${md_bind}
Subject: 554 5.7.1 [P2] Message blocked due to spam content in the message.

Your email was rejected for policy reasons.  Reasons for rejection may be related to content with spam-like characteristics or IP/domain reputation problems.  Please contact your Email/Internet Service Provider for additional help.

%{rfc2822:message}
.
;

                vctx_mess_set "xbl_xorg_responce" "${response}";
	        	ec_discard "CMAE Spam:Discarded spam:SMTP";
        		stop;
			}
		}
		elsif ec_test :is "${zen}" ["127.0.0.3"] {
			vctx_mess_set "sbl_response" "${response}";
			ec_inc_counter "RBL:SBL:SMTP";
			ec_header_add "X-SPAMHAUS" "CSS";
			ec_header_add "X-Spam-Flag" "YES";
		}
	}
}

# check analysis header for whitelist and keep count
# whitelisted by CMAE (whitelist.cfg)
if vctx_mess :contains "cmae-analysis" "wl=" {
	ec_header_add "X-CMAE-Whitelist" "YES";
	ec_inc_counter "CM Whitelist:Whitelisted";
}

# Add user whitelist header
if vctx_mess :is "user_wl" "yes" {
    ec_header_add "X-User-Whitelist" "YES";
}    

# Add mail from  whitelist header
if vctx_mess :is "mailfrom_wl" "yes" {
    ec_header_add "X-MailFrom-Whitelist" "YES";
}

# Add rcptto whitelist header
if vctx_mess :is "rcptto_wl" "yes" {
    ec_header_add "X-RcptTo-Whitelist" "YES";
}

# Insert a subject if we don't have one.
# Set a subject vctx entry for use in the Perl-based rejectlog'er
if exists "Subject" {
	($hdr) = ec_header_get "Subject";
	vctx_mess_set "subject" "${hdr}";
} 
else {
	ec_header_add "Subject" "<No Subject>";
	vctx_mess_set "subject" "no subject";
}

# This query is to find the proper maildrop host and forwarding address
# for each user. 
$params_md = hash_create;
hash_set $params_md "to" $recipient;
hash_set $params_md "user" $rcpt_localpart;
hash_set $params_md "domain" $rcpt_domain;
hash_set $params_md "ldap_pw" $ldap_pass;

# Check each rcpt to domain
$results_each_domain = ds_fetch_hash "domain_check" "ldap:///?zimbraDomainAliasTargetId,zimbraDomainType,zimbraDomainName?sub?(&(zimbraDomainName=$domain)(zimbraDomainType=*)(zimbraMailStatus=enabled))?x-ldap-version=3,bindname=uid=zimbra%2ccn=admins%2ccn=zimbra,x-bindpw=$ldap_pw" $params_md;

# Check if domain is an alias
$is_alias = $results_each_domain["zimbraDomainType"];
if ec_test :is "${is_alias}" "alias" {
    # Look up alias domain name
    $alias_domain_id =  $results_each_domain["zimbraDomainAliasTargetId"];
    $params_domain_alias = hash_create;
    hash_set $params_domain_alias "domain" $alias_domain_id;
    hash_set $params_domain_alias "ldap_pw" $ldap_pass;
                        
    $results_alias_domain = ds_fetch_hash "domain_check" "ldap:///?zimbraDomainName?sub?(&(objectClass=zimbraDomain)(zimbraId=$domain))?x-ldap-version=3,bindname=uid=zimbra%2ccn=admins%2ccn=zimbra,x-bindpw=$ldap_pw" $params_domain_alias;
    # Lookup user@alias_domain
    $alias_domain = $results_alias_domain["zimbraDomainName"];
    $recipient = "${rcpt_localpart}@${alias_domain}";
    $params_user_alias = hash_create;
    hash_set $params_user_alias "to" $recipient;
    hash_set $params_user_alias "user" $rcpt_localpart;
    hash_set $params_user_alias "domain" $alias_domain;
    hash_set $params_user_alias "ldap_pw" $ldap_pass;

    $results_md = ds_fetch_hash "md_check" "ldap:///?objectClass,zimbraMailDeliveryAddress,zimbraCOSId,zimbraMailHost,zimbraMailForwardingAddress,zimbraPrefMailForwardingAddress,zimbraPrefMailLocalDeliveryDisabled?sub?(&(|(zimbraMailDeliveryAddress=$to)(zimbraMailAlias=$to))(zimbraMailStatus=enabled))?x-ldap-version=3,bindname=uid=zimbra%2ccn=admins%2ccn=zimbra,x-bindpw=$ldap_pw" $params_user_alias;
    vctx_mess_set "local_each_rcpt" "yes";
    # If the users alias does not exist see if a catch all address exists
    if not isset $results_md "zimbraMailHost" {
        $results_catch_all = ds_fetch_hash "catch_all_check" "ldap:///?zimbraMailDeliveryAddress?sub?(&(zimbraMailCatchAllAddress=@$domain)(zimbraMailStatus=enabled))?x-ldap-version=3,bindname=uid=zimbra%2ccn=admins%2ccn=zimbra,x-bindpw=$ldap_pw" $params_user_alias;
        $catch_all_addy = $results_catch_all["zimbraMailDeliveryAddress"];
        vctx_mess_set "catch" "${catch_all_addy}";
        if isset $results_catch_all "zimbraMailDeliveryAddress" {
            $from = "%{vctx_mess:mailfrom_localpart}@%{vctx_mess:mailfrom_domain}";
            $to = $results_catch_all["zimbraMailDeliveryAddress"];
            $orginal_to = "%{vctx_mess:rcptto_localpart}@%{vctx_mess:rcptto_domain}";

generate_mail_raw $from $to text:
From: ${from}
To: ${orginal_to}
%{rfc2822:message}
.
;

            discard;
        }
    }
#    else {
        # Rewrite the alias rcpt
#        $from = "%{vctx_mess:mailfrom_localpart}@%{vctx_mess:mailfrom_domain}";
#        $to = $results_md["zimbraMailDeliveryAddress"];
#        $orginal_to = "%{vctx_mess:rcptto_localpart}@%{vctx_mess:rcptto_domain}";

#generate_mail_raw $from $to text:
#From: ${from}
#To: ${orginal_to}
#%{rfc2822:message}
#.
#;
#
#        discard;
#    }
}
else {
    # The domain is not an alias so is it a Zimbra domain?
    if isset $results_each_domain "zimbraDomainName" {
        $results_md = ds_fetch_hash "md_check" "ldap:///?objectClass,zimbraCOSId,zimbraMailHost,zimbraMailForwardingAddress,zimbraPrefMailForwardingAddress,zimbraMailCatchAllAddress,zimbraPrefMailLocalDeliveryDisabled?sub?(&(|(zimbraMailDeliveryAddress=$to)(zimbraMailAlias=$to))(zimbraMailStatus=enabled))?x-ldap-version=3,bindname=uid=zimbra%2ccn=admins%2ccn=zimbra,x-bindpw=$ldap_pw" $params_md;
        vctx_mess_set "local_each_rcpt" "yes";
        # If the users does not exist see if a catch all address exists.
        if not isset $results_md "zimbraMailHost" {
            $results_catch_all = ds_fetch_hash "catch_all_check" "ldap:///?zimbraMailDeliveryAddress?sub?(&(zimbraMailCatchAllAddress=@$domain)(zimbraMailStatus=enabled))?x-ldap-version=3,bindname=uid=zimbra%2ccn=admins%2ccn=zimbra,x-bindpw=$ldap_pw" $params_md;
            $catch_all_addy = $results_catch_all["zimbraMailDeliveryAddress"];
            vctx_mess_set "catch" "${catch_all_addy}";
            if isset $results_catch_all "zimbraMailDeliveryAddress" {
                $from = "%{vctx_mess:mailfrom_localpart}@%{vctx_mess:mailfrom_domain}";
                $to = $results_catch_all["zimbraMailDeliveryAddress"];
                $orginal_to = "%{vctx_mess:rcptto_localpart}@%{vctx_mess:rcptto_domain}";

generate_mail_raw $from $to text:
From: ${from}
To: ${orginal_to}
%{rfc2822:message}
.
;

             discard;
            }
            if anyof (ec_test :is $rcpt_domain "6newslawrence.com", ec_test :is $rcpt_domain "freestatestudios.com") {
                vctx_conn_set "nonzim" "yes";
            }   
        }
    }
}

# If the rcptto is a premium use deliver premium spam!
$cosid = $results_md["zimbraCOSId"];
if anyof (ec_test :is "${cosid}" "${default_premium_cos}", ec_test :is "${cosid}" "${biz_premium_cos}") {
    #vctx_mess_set "premium_wl" "yes";
}

# If no whitelist context exist check for spam.
if not vctx :is ["conn_wl", "mailfrom_wl", "rcptto_wl", "user_wl", "internal_wl"] "yes" {
    $score = cloudmark_score;
    ec_header_add "X-Scanned-by" "Cloudmark Authority Engine";
    ec_header_add "X-CM-Score" "%{vctx_mess:cmae-score}";
    ec_header_add "X-CNFS-Analysis" "%{vctx_mess:cmae-analysis}";
    ec_header_add "X_CMAE_Category" "%{vctx_mess:cmae-category},%{vctx_mess:cmae-subcategory} %{vctx_mess:cmae-category-desc},%{vctx_mess:cmae-subcategory-desc}";
    # Deliver HELO User to spam foldecore = cloudmark_score;
    if vctx_conn :is "smtp_relay" "true" {
        if vctx_conn :is :comparator "i;ascii-casemap" "ehlo_domain" "user" {
            if not vctx_mess :is "premium_wl" "yes" {
                #ec_header_add "X-Spam-Rating" "**";
                ec_log_file "/var/log/ecelerity/logging.ec" "%{t} %{spfv1:i} ${sender} - Marked as spam for HELO User.";
                ec_log_file "jlog:///var/log/ecelerity/logging.cluster=>master" "%{t} %{spfv1:i} ${sender} - Marked as spam for HELO User.";
                ec_discard;
            }
            else {
                ec_header_add "X-Spam-Rating" "**";
            }
        }
        if vctx_conn :is :comparator "i;ascii-casemap" "%{vctx_mess:rcptto_domain}" "localhost" {
            ec_discard;
            ec_log_file "/var/log/ecelerity/logging.ec" "%{t} discarded localhost rcptto";
            ec_log_file "jlog:///var/log/ecelerity/logging.cluster=>master" "%{t} discarded localhost rcptto";
        }
    }            
    
	# Check if Spamhaus CSS and add header
	if vctx_conn :is "sbl" "true" {
		ec_header_add "X-SPAMHAUS" "CSS";
        #ec_header_add "X-Spam-Flag" "YES";
        ec_header_add "X-Spam-Rating" "**";
		if vctx_conn :is "mx" "true" {
            ec_inc_counter "RBL:SBL:MX";
        }
        else {
            ec_inc_counter "RBL:SBL:SMTP";
        }         
    }
    if vctx_conn :is "pbl" "true" {
        if vctx_conn :is "mx" "true" {
            #ec_header_add "X-Spam-Flag" "YES";
            ec_header_add "X-Spam-Rating" "*";
        } 
    }
    
	# Check if exist as CSI suspect and add header
	if vctx_conn :is "csi_result" "Suspect Reputation by Cloudmark"{
		ec_header_add "X-CLOUDMARK-CSI" "SUSPECT";
        #ec_header_add "X-Spam-Flag" "YES";
        ec_header_add "X-Spam-Rating" "**";
        if vctx_conn :is "mx" "true" {
          	ec_inc_counter "CMAE Spam:Suspect spam:MX";
        }
        else {
            ec_inc_counter "CMAE Spam:Suspect spam:SMTP";
        }
	}
	# Check the CMAE Scores.  Anything > 98 is spam
	if ec_test :value "ge" :comparator "i;ascii-numeric" "${score}" "96" {
		#ec_discard "CMAE Spam:Discarded spam";
		if vctx_conn :is "mx" "true" {
            if not ec_test :is "${as_wl}" "true" {
                audit_series_add $ib_rejections;
                audit_series_add $ib_spam_vol;
            }
            if not vctx_mess :is "premium_wl" "yes" {
			    ec_disconnect 554 "5.7.1 [P4] Message blocked due to spam content in the message." "CMAE Spam:Discarded spam:MX";
            }
            else {
                ec_header_add "X-Spam-Rating" "**";
            }
		}
		else {
            if not ec_test :is "${as_wl}" "true" {
                audit_series_add $ob_rejections;
                audit_series_add $ob_spam_vol;
            }
            if not vctx_mess :is "premium_wl" "yes" {
			    ec_discard "CMAE Spam:Discarded spam:SMTP";
            }
            else {
                ec_header_add "X-Spam-Rating" "**";
            }
		}
		stop;
	}
	elsif ec_test :value "ge" :comparator "i;ascii-numeric" "${score}" "95" {
		if vctx :contains "pbl" "" {
			ec_inc_counter "CMAE+PBL:CMAE SUSPECT+PBL";
			if vctx_conn :is "mx" "true" {
                if not ec_test :is "${as_wl}" "true" {
                    audit_series_add $ib_rejections;
                    audit_series_add $ib_spam_vol;
                }
                if not vctx_mess :is "premium_wl" "yes" {
				    ec_disconnect 554 "5.7.1 [P5] Message blocked due to spam content in the message." "CMAE Spam:Discarded spam:MX";
                }
                else {
                    ec_header_add "X-Spam-Rating" "**";
                }
			}
			else {
                if not ec_test :is "${as_wl}" "true" {
                    audit_series_add $ob_rejections;
                    audit_series_add $ob_spam_vol;
                }
                if not vctx_mess :is "premium_wl" "yes" {
				    ec_discard "CMAE Spam:Discarded spam:SMTP";
                }
                else {
                    ec_header_add "X-Spam-Rating" "**";
                }
			}
		}
		else {
		    ec_header_add "X-CLOUDMARK" "SUSPECT";
			#ec_header_add "X-Spam-Flag" "YES";
            ec_header_add "X-Spam-Rating"  "*";
			if vctx_conn :is "mx" "true" {
                if not ec_test :is "${as_wl}" "true" {
                    audit_series_add $ib_suspect_vol;
                }
	            ec_inc_counter "CMAE Spam:Suspect spam:MX";
		    }
		    else {
                if not ec_test :is "${as_wl}" "true" {
                    audit_series_add $ob_suspect_vol;
                }
			    ec_inc_counter "CMAE Spam:Suspect spam:SMTP";
		    }
	    }
    }
    else {
        if not vctx :is "as_wl" "true" {
	        if vctx_conn :is "mx" "true" {
                if not ec_test :is "${as_wl}" "true" {
                    audit_series_add $ib_legit_vol;
                }
		        ec_inc_counter "CMAE Legit:Legit Mail:MX";
	        }
	        else {
                if not ec_test :is "${as_wl}" "true" {
                    audit_series_add $ob_legit_vol;
                }
		        ec_inc_counter "CMAE Legit:Legit Mail:SMTP";
	        }
        }        
    }
}

# if sending email strip spf headers    
if vctx_mess :is "smtp_relay" "true" {
	ec_header_delete "spf_header";
	ec_header_delete "Received-SPF";
}

# Check for too many mail froms
if vctx :is "webmail_bounce_mailfroms" "yes" {
    ec_discard;
}   
if vctx :is "too_many_mailfroms" "yes" {
	if vctx :is "mailpost_alert" "yes" {
	}
	else {
        $to = "${postmaster}";
        $from = "${mailer_daemon}";

generate_mail_raw $from $to text:
From: ${from}
To: ${to} 
Subject: Too many Messages from ${sender} ( %{vctx_conn:auth_user} )

${sender} ( %{vctx_conn:auth_user} )has tried to send too many messages in an hour.  


%{rfc2822:message}
.
;

	    if exists "X-Originating-IP" {
		    $md_bind = vctx_conn_get "ehlo_domain";
		    $mf_local = vctx_mess_get "mailfrom_localpart";
		    $mf_domain = vctx_mess_get "mailfrom_domain";
		    if vctx_conn :contains "ehlo_domain" ".${cluster}" {
			    vctx_mess_set "maildrop" "${md_bind}";
			    $from = "${mailer_daemon}";
			    $to = "${mf_local}@${mf_domain}";

# Generate bonce message for webmail users. NOTE: generate_mail_raw does not like tabbed spacing
generate_mail_raw $from $to text:
From: ${from}
To: ${to}
X-BINDING: ${md_bind}
Subject: 452 4.7.0 [P6] Too many messages sent.

Your message was not delivered because you have sent too many messages.

%{rfc2822:message}
.
;
		
		        ec_discard;
		    }
	    }
        vctx_mess_set "mailpost_alert" "yes";
    }
}

# Too many rccpto check.
if vctx :is "too_many_rcpttos" "yes" {
    if vctx :is "post_alert" "yes" {
    }
    else {
        $to = "${postmaster}";
        $from = "${mailer_daemon}";

generate_mail_raw $from $to text:
From: ${from}
To: ${to}
Subject: Too many Recipients from ${sender} ( %{vctx_conn:auth_user} )

${sender} ( %{vctx_conn:auth_user} )has tried to send to too many recipients

Number of Recipients:
%{vctx_conn:message_rcpt_count}



%{rfc2822:message}
.
;

	    if exists "X-Originating-IP" {
		    $md_bind = vctx_conn_get "ehlo_domain";
		    $mf_local = vctx_mess_get "mailfrom_localpart";
		    $mf_domain = vctx_mess_get "mailfrom_domain";
		    if vctx_conn :contains "ehlo_domain" ".${cluster}" {
			    vctx_mess_set "maildrop" "${md_bind}";
			    $from = "${mailer_daemon}";
			    $to = "${mf_local}@${mf_domain}";

# Generate bonce message for webmail users. NOTE: generate_mail_raw does not like tabbed spacing
generate_mail_raw $from $to text:
From: ${from}
To: ${to}
X-BINDING: ${md_bind}
Subject: 452 4.5.3 [P7] Too many recipients in one message. 

Please reduce the number of recipients.

%{rfc2822:message}
.
;

			    ec_discard;
		    }
	    }
        vctx_mess_set "post_alert" "yes";
        if not ec_test :is "${as_wl}" "true" {
            audit_series_add $ob_rejections;
            audit_series_add $ob_recipient_violations;
        }
	    ec_disconnect 452 "4.5.3 [P8] Too many recipients in one message.";
	}
}


# Added to make zimbraDistributionList work.
$objclass = $results_md["objectClass"];
if ec_test :is "${objclass}" "zimbraDistributionList" {
    $from = "%{vctx_mess:mailfrom_localpart}@%{vctx_mess:mailfrom_domain}";
    $to = $results_md["zimbraMailForwardingAddress"];
    
generate_mail_raw $from $to text:
%{rfc2822:message}
.
;

    discard;
}    
        
if isset $results_md "zimbraMailForwardingAddress" {
    $sender = envelope "from";
    $recipient = $results_md["zimbraMailForwardingAddress"];
	vctx_mess_set "forwardto" "${recipient}";
	ec_header_add "X-Forwarded-To" "${recipient}";
	add_recipient "${recipient}";    
}

if isset $results_md "zimbraPrefMailForwardingAddress" {
    $sender = envelope "from";
    $to = envelope "to";
    $fwdadd = $results_md["zimbraPrefMailForwardingAddress"];
    ($a,$b,$c,$d,$e,$f,$g,$h,$i,$j) = split ",\ " "${fwdadd}";
    vctx_mess_set "forwardto" "${fwdadd}";
    ec_header_add "X-Forwarded-To" "${fwdadd}";
    ec_header_add "X-Forwarded-For" "${to} ${fwdadd}";
    if not ec_test :is "${a}" "" {
        add_recipient "${a}"; 
    }
    if not ec_test :is "${b}" "" {
        add_recipient "${b}"; 
    }
    if not ec_test :is "${c}" "" {
        add_recipient "${c}"; 
    }
    if not ec_test :is "${d}" "" {
        add_recipient "${d}"; 
    }
    if not ec_test :is "${e}" "" {
        add_recipient "${e}"; 
    }
    if not ec_test :is "${f}" "" {
        add_recipient "${f}"; 
    }
    if not ec_test :is "${g}" "" {
        add_recipient "${g}"; 
    }
    if not ec_test :is "${h}" "" {
        add_recipient "${h}"; 
    }
    if not ec_test :is "${i}" "" {
        add_recipient "${i}"; 
    }
    if not ec_test :is "${j}" "" {
        add_recipient "${j}"; 
    }
}

$deliverdisabled = $results_md["zimbraPrefMailLocalDeliveryDisabled"];
if ec_test :is $deliverdisabled "TRUE" {
	ec_discard "Disabled local delivery";
	stop;
}

# Set Binding context
$cosid = $results_md["zimbraCOSId"];
vctx_mess_set "cos" "${cosid}";
$maildrophost = $results_md["zimbraMailHost"];
vctx_mess_set "maildrophost" "${maildrophost}";
if anyof (ec_test :is $cosid  "${default_cos1}", ec_test :is $cosid  "${default_cos2}", ec_test :is $cosid  "${default_cos3}", ec_test :is $cosid  "${default_cos4}") {
    $maildrophost = $results_md["zimbraMailHost"];
    vctx_mess_set "maildrop" "${maildrophost}";
    vctx_mess_set "x-binding" "${maildrophost}";
    stop;
}
elsif anyof (ec_test :is $cosid  "${premig_cos1}", ec_test :is $cosid  "${premig_cos2}", ec_test :is $cosid  "${premig_cos3}", ec_test :is $cosid  "${premig_cos4}") {
    vctx_mess_set "premigration" "yes";
    vctx_mess_set "maildrop" "${premig_binding}";
    ec_header_add "x-binding" "${premig_binding}";
    stop;
}
elsif vctx_mess :is "local_each_rcpt" "yes" {
    #$maildrophost = $results_md["zimbraMailHost"];
    #vctx_mess_set "maildrop" "${maildrophost}";
    #vctx_mess_set "x-binding" "${maildrophost}";
    vctx_mess_set "premigration" "yes";
    vctx_mess_set "maildrop" "${premig_binding}";
    ec_header_add "x-binding" "${premig_binding}";
    stop;
}

# Fail over IP delivery
if vctx_conn :is "smtp_relay" "true" {
    $failover_domain = ds_fetch "fail_check" "SELECT fail FROM ec_failover_domains WHERE address = ?" ["%{vctx_mess:rcptto_domain}"];
    $failover_all = ds_fetch "fail_check" "SELECT fail FROM ec_failover_domains WHERE address = 'ALL'";
    if ec_test :is :comparator "i;ascii-casemap" "${failover_domain}" "1" {
        vctx_mess_set "maildrop" "failover";
        stop;
    }
# Failover all outbound traffic
    if ec_test :is :comparator "i;ascii-casemap" "${failover_all}" "1" {
        vctx_mess_set "maildrop" "failover";
        stop;
    }
}    
