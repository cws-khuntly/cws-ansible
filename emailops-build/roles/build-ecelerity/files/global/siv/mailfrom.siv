### Mail From Phase ###

# Include client variables
ec_include "/opt/msys/ecelerity/etc/conf/global/siv/client_vars.siv";

# As_logger includes
ec_include "/opt/msys/ecelerity/etc/conf/global/siv/in_def_audit_series.siv";
ec_include "/opt/msys/ecelerity/etc/conf/global/siv/out_def_audit_series.siv";

# grab mail from address
$mail_from = "%{vctx_mess:mailfrom_localpart}@%{vctx_mess:mailfrom_domain}";
$mail_from_localpart = "%{vctx_mess:mailfrom_localpart}";
$mail_from_domain = "%{vctx_mess:mailfrom_domain}";


# mail from blacklist check
if not ec_test :is "${mail_from}" "@" {
    if vctx_conn :is "mx" "true" {
        ($mailfrom_domain_bl) = ds_fetch "wlbl" "SELECT inbound FROM ec_mailfrom_bl_addresses WHERE address LIKE ?" ["%{vctx_mess:mailfrom_domain}"];
        if ec_test :is :comparator "i;ascii-casemap" "${mailfrom_domain_bl}" "1" {
            if not ec_test :is "${as_wl}" "true" {
                audit_series_add $ib_rejections;
                audit_series_add $ib_envelope_violations;
            }
            ec_action 550 "5.7.1 [F1] Mail rejected by policy.  Blacklisted" "policy:mailfrom blacklist";
        }
        else {
            ($mailfrom_bl) = ds_fetch "wlbl" "SELECT inbound FROM ec_mailfrom_bl_addresses WHERE address LIKE ?" ["%{vctx_mess:mailfrom_localpart}@%{vctx_mess:mailfrom_domain}"];
            if ec_test :is :comparator "i;ascii-casemap" "${mailfrom_bl}" "1" {
                if not ec_test :is "${as_wl}" "true" {
                    audit_series_add $ib_rejections;
                    audit_series_add $ib_envelope_violations;
                }
                ec_action 550 "5.7.1 [F2] Mail rejected by policy.  Blacklisted" "policy:mailfrom blacklist";
            }
        }
    }
    if vctx_conn :is "smtp_relay" "true" {
        ($mailfrom_domain_bl) = ds_fetch "wlbl" "SELECT outbound FROM ec_mailfrom_bl_addresses WHERE address LIKE ?" ["%{vctx_mess:mailfrom_domain}"];
        if ec_test :is :comparator "i;ascii-casemap" "${mailfrom_domain_bl}" "1" {
            if not ec_test :is "${as_wl}" "true" {
                audit_series_add $ob_rejections;
                audit_series_add $ob_envelope_violations;
            }
            ec_action 550 "5.7.1 [F3] Mail rejected by policy.  Blacklisted" "policy:mailfrom blacklist";
        }
        else {
            ($mailfrom_bl) = ds_fetch "wlbl" "SELECT outbound FROM ec_mailfrom_bl_addresses WHERE address LIKE ?" ["%{vctx_mess:mailfrom_localpart}@%{vctx_mess:mailfrom_domain}"];
            if ec_test :is :comparator "i;ascii-casemap" "${mailfrom_bl}" "1" {
                if not ec_test :is "${as_wl}" "true" {
                    audit_series_add $ob_rejections;
                    audit_series_add $ob_envelope_violations;
                }
                ec_action 550 "5.7.1 [F4] Mail rejected by policy.  Blacklisted" "policy:mailfrom blacklist";
            }
        }
    }
    # mail from whitelist check
    ($mailfrom_wl) = ds_fetch "wlbl" "SELECT address FROM ec_mailfrom_wl_addresses WHERE address = ?" ["%{vctx_mess:mailfrom_localpart}@%{vctx_mess:mailfrom_domain}"];
    if ec_test :is :comparator "i;ascii-casemap" "${mailfrom_wl}" "%{vctx_mess:mailfrom_localpart}@%{vctx_mess:mailfrom_domain}" {
        vctx_mess_set "mailfrom_wl" "yes";
    }
    # mail from rate limit whitelist check
    if vctx_conn :is "smtp_relay" "true" {
        $sender_domain_wl_check = ds_fetch "wlbl" "select address from ec_sender_msg_limit_wl where address = ?" ["%{vctx_mess:mailfrom_domain}"];
        if ec_test :is "${sender_domain_wl_check}" "%{vctx_mess:mailfrom_domain}" {
            vctx_mess_set "from_rate_wl" "true";
        }
        else {
            $sender_user_wl_check = ds_fetch "wlbl" "select address from ec_sender_msg_limit_wl where address = ?" ["%{vctx_mess:mailfrom_localpart}@%{vctx_mess:mailfrom_domain}"];
            if ec_test :is "${sender_user_wl_check}" "%{vctx_mess:mailfrom_localpart}@%{vctx_mess:mailfrom_domain}" {
                vctx_mess_set "from_rate_wl" "true";
            }
        }
    }
}    

# Check for empty envelope from
# Just keep count for now
#if envelope :all :is "from" "@" {
#       ec_inc_counter "empty mail from";
#}

# accept null senders
if vctx :regex "mailfrom_string" "(?i)MAIL FROM:[ ]*<>" {
    ec_inc_counter "empty mail from";
    ec_action 250 "Null sender accepted" "Accepted";
    stop;
}

# Check that mailfroms claiming to be from local domains actually exist
# LDAP checks for sender.  If send is from one one of the local
# domains, then check to see if the sender really exists

# set variables for the hash
$sender = envelope :all "from";
$from_domain = envelope :domain "from";
$from_localpart = envelope :localpart "from";
$auth_user = vctx_conn_get "auth_user";

if not ec_test :contains :comparator "i;ascii-casemap" "${auth_user}" "@" {
	$listener_domain = vctx_conn_get "listener_domain";
	$auth_user = "${auth_user}@${listener_domain}";
}

# create a hash of values to send into the ldap string 
$params_user = hash_create; 
hash_set $params_user "from" $sender;
hash_set $params_user "user" $from_localpart;
hash_set $params_user "domain" $from_domain;
hash_set $params_user "ldap_pw" $ldap_pass;
hash_set $params_user "auth" $auth_user;

if vctx_conn :contains "auth_user" "" {
    $results_auth_user = ds_fetch_hash "user_check" "ldap:///?zimbraAccountStatus?sub?(|(zimbraMailDeliveryAddress=$auth)(zimbraMailAlias=$auth))?x-ldap-version=3,bindname=uid=zimbra%2ccn=admins%2ccn=zimbra,x-bindpw=$ldap_pw" $params_user;
	$auth_suspended = $results_auth_user["zimbraAccountStatus"];
    vctx_mess_set "auth_status_mailfrom" "${auth_suspended}";
    if vctx_conn :is "mx" "true" {
        if anyof (ec_test :is "${auth_suspended}" "locked", ec_test :is "${auth_suspended}" "closed", ec_test :is "${auth_suspended}" "lockout"){
            ec_inc_counter "stats:Invalid from address:MX";
            if not ec_test :is "${as_wl}" "true" {
                audit_series_add $ib_rejections;
                audit_series_add $ib_envelope_violations;
            }
            ec_action 501 "5.1.8 [F19] Sender ${sender} mailbox is unavailable."  "User Rejected:Invalid from address";
        }
    }
    else {
        if anyof (ec_test :is "${auth_suspended}" "locked", ec_test :is "${auth_suspended}" "closed", ec_test :is "${auth_suspended}" "lockout"){
            ec_inc_counter "stats:Invalid from address:SMTP";
            if not ec_test :is "${as_wl}" "true" {
                audit_series_add $ob_rejections;
                audit_series_add $ob_envelope_violations;
            }
            ec_action 501 "5.1.8 [F20] Sender ${sender} mailbox is unavailable."  "User Rejected:Invalid from address";
        }
    }
}

# use ds_fetch_hash with the ldap string
$results_domain = ds_fetch_hash "domain_check" "ldap:///?zimbraDomainName?sub?(&(zimbraDomainName=$domain)(zimbraDomainType=local)(zimbraMailStatus=enabled))?x-ldap-version=3,bindname=uid=zimbra%2ccn=admins%2ccn=zimbra,x-bindpw=$ldap_pw" $params_user;

# all domains that exist in ldap have the "domainname"
# attribute.  So, we will now check for that.
if isset $results_domain "zimbraDomainName" {
    vctx_mess_set "local_from_domain" "true";
    # now check to see if user is in a domain
    $results_user = ds_fetch_hash "user_check" "ldap:///?zimbraMailDeliveryAddress,zimbraMailHost,zimbraCOSId,zimbraMailAlias,zimbraMailCatchAllAddress,zimbraAccountStatus?sub?(&(|(zimbraMailDeliveryAddress=$from)(zimbraMailAlias=$from)(zimbraMailCatchAllAddress=$from))(zimbraMailStatus=enabled))?x-ldap-version=3,bindname=uid=zimbra%2ccn=admins%2ccn=zimbra,x-bindpw=$ldap_pw" $params_user;
    if not anyof (isset $results_user "zimbraMailDeliveryAddress", isset $resutlts_user "zimbraMailAlias", isset $resutlts_user "zimbraMailCatchaAllAddress", vctx :is "auth_status" "pass") {
        if vctx_conn :is "mx" "true" {
            ec_inc_counter "stats:Invalid from address:MX";
            if not ec_test :is "${as_wl}" "true" {
                audit_series_add $ib_rejections;
                audit_series_add $ib_envelope_violations;
            }
            #ec_action 550 "5.1.8 [F8] Sender ${sender} does not exist here."  "User Rejected:Invalid from address";
        }
        else {
            ec_inc_counter "stats:Invalid from address:SMTP";
            if not ec_test :is "${as_wl}" "true" {
                audit_series_add $ob_rejections;
                audit_series_add $ob_envelope_violations;
            }
            #ec_action 550 "5.1.8 [F9] Sender ${sender} does not exist here."  "User Rejected:Invalid from address";
        }
    }

	# Check to see if the account is active and if not fail
	$suspended = $results_user["zimbraAccountStatus"];
	vctx_mess_set "from_status" "${suspended}";
	if vctx_conn :is "mx" "true" {
		if anyof (ec_test :is "${suspended}" "locked", ec_test :is "${suspended}" "closed", ec_test :is "${suspended}" "lockout", ec_test :is "${auth_suspended}" "locked", ec_test :is "${auth_suspended}" "closed", ec_test :is "${auth_suspended}" "lockout")   {
			ec_inc_counter "stats:Invalid from address:MX";
			if not ec_test :is "${as_wl}" "true" {
				audit_series_add $ib_rejections;
				audit_series_add $ib_envelope_violations;
			}
			ec_action 501 "5.1.8 [F17] Sender ${sender} mailbox is unavailable."  "User Rejected:Invalid from address";
		}
	}
	else {
		if anyof (ec_test :is "${suspended}" "locked", ec_test :is "${suspended}" "closed", ec_test :is "${suspended}" "lockout", ec_test :is "${auth_suspended}" "locked", ec_test :is "${auth_suspended}" "closed", ec_test :is "${auth_suspended}" "lockout")   {
			ec_inc_counter "stats:Invalid from address:SMTP";
			if not ec_test :is "${as_wl}" "true" {
				audit_series_add $ob_rejections;
				audit_series_add $ob_envelope_violations;
			}
			ec_action 501 "5.1.8 [F18] Sender ${sender} mailbox is unavailable."  "User Rejected:Invalid from address";
		}
	}
}

# Mail from and auth thresholds
if not anyof (vctx_mess :is "mailfrom_wl" "yes", vctx_mess :is "from_rate_wl" "true", vctx_conn :is "msg_rate_wl" "true", vctx_conn :is "dp_whitelist_global" "true") {
    # Webmail mail from gauge
    if vctx_conn :is "trusted" "yes" {
        ec_gauge_cache_init "trust_hour_count_list" 10000 3600 1;
        ec_gauge_cache_init "trust_hour_block_list" 2500 3600 1;
        
        # If the webmail user sends more messages than the mailfrom_threshold disconnect else incriment the hour count list.
        $trust_block_test = ec_gauge_cache_get "trust_hour_block_list" "${mail_from}";
        if not ec_test :is "${mail_from}" "@" {
            # internalwhitelist check
            ($internal_wl) = ds_fetch "wlbl" "SELECT address FROM ec_internal_wl_addresses WHERE address = ?" ["%{vctx_mess:mailfrom_localpart}@%{vctx_mess:mailfrom_domain}"];
            if ec_test :is :comparator "i;ascii-casemap" "${mailfrom_wl}" "%{vctx_mess:mailfrom_localpart}@%{vctx_mess:mailfrom_domain}" {
                vctx_mess_set "internal_wl" "yes";
            }
            if not vctx_mess :is "internal_wl" "yes"{    
                if ec_test :value "gt" :comparator "i;ascii-numeric" "${trust_block_test}" "0" {
                    vctx_mess_set "webmail_bounce_mailfroms" "yes";
                }
                else {
                    ec_gauge_cache_inc "trust_hour_count_list" "${mail_from}";
                    $usercos = $results_user["zimbraCOSId"];
                    if anyof (ec_test :is $usercos "$default_cos", ec_test :is $usercos "$premig_cos") {
                        # If the trust_hour_count_list is above the mailfrom_threshold add to the trust_hour_block_list.
                        $trust_hour_count_test = ec_gauge_cache_get "trust_hour_count_list" "${mail_from}";
                        if ec_test :value "gt" :comparator "i;ascii-numeric" "${trust_hour_count_test}" "${web_from_log_threshold}" {
                            ec_log_file "/var/log/ecelerity/logging.ec" "%{t} %{spfv1:i} ${mail_from} - exceeded webmail logging threshold ${web_from_log_threshold}";
                            ec_log_file "jlog:///var/log/ecelerity/logging.cluster=>master" "%{t} %{spfv1:i} ${mail_from} - exceeded webmail logging threshold ${web_from_log_threshold}";
                        }    
                        if ec_test :value "gt" :comparator "i;ascii-numeric" "${trust_hour_count_test}" "${web_from_threshold}" {
                            ec_gauge_cache_inc "trust_hour_block_list" "${mail_from}";
                            vctx_mess_set "too_many_mailfroms" "yes";
                        }
                    }
                    else {
                        # If the trust_hour_count_list is above the mailfrom_threshold add to the trust_hour_block_list.
                        $trust_hour_count_test = ec_gauge_cache_get "trust_hour_count_list" "${mail_from}";
                        if ec_test :value "gt" :comparator "i;ascii-numeric" "${trust_hour_count_test}" "${web_from_log_threshold}" {
                            ec_log_file "/var/log/ecelerity/logging.ec" "%{t} %{spfv1:i} ${mail_from} - exceeded webmail logging threshold ${web_biz_log_threshold}";
                            ec_log_file "jlog:///var/log/ecelerity/logging.cluster=>master" "%{t} %{spfv1:i} ${mail_from} - exceeded webmail biz logging threshold ${web_from_log_threshold}";
                        }    
                        if ec_test :value "gt" :comparator "i;ascii-numeric" "${trust_hour_count_test}" "${web_biz_threshold}" {
                            ec_gauge_cache_inc "trust_hour_block_list" "${mail_from}";
                            vctx_mess_set "too_many_mailfroms" "yes";
                        }
                    }
                }
            }              
        }
    }   

    # No Auth gauge 
    if vctx_conn :is "ip_allow_list" "yes" {
        if vctx_conn :is "smtp_relay" "true" {
            if not vctx_conn :is "auth_status" "pass" {  
	         ec_gauge_cache_init "hour_count_list" 10000 3600 1;
	         ec_gauge_cache_init "hour_block_list" 2500 3600 1;
            
                # If an no auth user sends more messages than the mailfrom_threshold disconnect else incriment the hour count list.
	            $block_test = ec_gauge_cache_get "hour_block_list" "${mail_from}";
		    if ec_test :value "gt" :comparator "i;ascii-numeric" "${block_test}" "0" {
                        if not ec_test :is "${as_wl}" "true" {
                            audit_series_add $ob_rejections;
                            audit_series_add $ob_envelope_violations;
                        }
			    ec_disconnect 452 "4.7.0 [F10] Too many messages sent.";
	            }	 
	            else {
		        ec_gauge_cache_inc "hour_count_list" "${mail_from}";
                        # If the hour_count_list is above the mailfrom_threshold add to the hour_block_list
		        $hour_count_test = ec_gauge_cache_get "hour_count_list" "${mail_from}";
                        if anyof (ec_test :is $usercos "$default_cos", ec_test :is $usercos "$premig_cos") {
		            if ec_test :value "gt" :comparator "i;ascii-numeric" "${hour_count_test}" "${smtp_noauth_log_threshold}" {
                                ec_log_file "/var/log/ecelerity/logging.ec" "%{t} %{spfv1:i} ${mail_from} - exceeded SMTP no auth threshold ${smtp_noauth_log_threshold}";
                                ec_log_file "jlog:///var/log/ecelerity/logging.cluster=>master" "%{t} %{spfv1:i} ${mail_from} - exceeded SMTP no auth threshold ${smtp_noauth_log_threshold}";
                            }
                        }
                        else {
                            if ec_test :value "gt" :comparator "i;ascii-numeric" "${hour_count_test}" "${smtp_noauth_log_threshold}" {
                                ec_log_file "/var/log/ecelerity/logging.ec" "%{t} %{spfv1:i} ${mail_from} - exceeded biz SMTP no auth threshold ${smtp_noauth_log_threshold}";
                                ec_log_file "jlog:///var/log/ecelerity/logging.cluster=>master" "%{t} %{spfv1:i} ${mail_from} - exceeded SMTP no auth threshold ${smtp_noauth_log_threshold}";
                            }
                        }                
		        if ec_test :value "gt" :comparator "i;ascii-numeric" "${hour_count_test}" "${smtp_noauth_threshold}" {
			    ec_gauge_cache_inc "hour_block_list" "${mail_from}";
			    vctx_mess_set "too_many_mailfroms" "yes";
                        }
                    }                    
                }
	    }
    } 

    # Smtp mail from gague
    if vctx_conn :is "smtp_relay" "true" {
        if vctx_conn :is "auth_status" "pass" {
            if vctx_conn :is "ip_allow_list" "yes" { 
                $auth_id = vctx_conn_get "auth_identity";
                ec_gauge_cache_init "relay_hour_count_list" 10000 3600 1;
                ec_gauge_cache_init "relay_hour_block_list" 2500 3600 1;
                # If an smtp auth user sends more messages than the mailfrom_threshold disconnect else incriment the hour count list.
                $block_test = ec_gauge_cache_get "relay_hour_block_list" "${auth_id}";
                if ec_test :value "gt" :comparator "i;ascii-numeric" "${block_test}" "0"{
                    if not ec_test :is "${as_wl}" "true" {
                        audit_series_add $ob_rejections;
                        audit_series_add $ob_rejections;
                    }
                    ec_disconnect 452 "4.7.0 [F11] Too many messages sent."; 
                } 
                else {
                    ec_gauge_cache_inc "relay_hour_count_list" "${auth_id}";
                    # If the hour_count_list is above the mailfrom_threshold add to the hour_block_list
                    $hour_count_test = ec_gauge_cache_get "relay_hour_count_list" "${auth_id}";
                    $usercos = $results_user["zimbraCOSId"];
                    vctx_mess_set "Count" "${hour_count_test}";
                    if anyof (ec_test :is $usercos "$default_cos", ec_test :is $usercos "$premig_cos") {
                        if ec_test :value "gt" :comparator "i;ascii-numeric" "${hour_count_test}" "${smtp_from_log_threshold}" {
                            ec_log_file "/var/log/ecelerity/logging.ec" "%{t} %{spfv1:i} ${auth_id} -  exceeded SMTP auth threshold ${smtp_from_log_threshold}";
                            ec_log_file "jlog:///var/log/ecelerity/logging.cluster=>master" "%{t} %{spfv1:i} ${auth_id} -  exceeded SMTP auth threshold ${smtp_from_log_threshold}";
                        }    
                        if ec_test :value "gt" :comparator "i;ascii-numeric" "${hour_count_test}" "${smtp_from_threshold}" {
                            ec_gauge_cache_inc "relay_hour_block_list" "${auth_id}";
                            vctx_mess_set "too_many_mailfroms" "yes";
                        }
                    }
                    else {
                        vctx_mess_set "biz_user" "yes";
                        if ec_test :value "gt" :comparator "i;ascii-numeric" "${hour_count_test}" "${smtp_biz_log_threshold}" {
                            ec_log_file "/var/log/ecelerity/logging.ec" "%{t} %{spfv1:i} ${auth_id} -  exceeded SMTP biz auth threshold ${smtp_biz_log_threshold}";
                            ec_log_file "jlog:///var/log/ecelerity/logging.cluster=>master" "%{t} %{spfv1:i} ${auth_id} -  exceeded SMTP biz auth threshold ${smtp_biz_log_threshold}";
                        }    
                        if ec_test :value "gt" :comparator "i;ascii-numeric" "${hour_count_test}" "${smtp_biz_threshold}" {
                            ec_gauge_cache_inc "relay_hour_block_list" "${auth_id}";
                            vctx_mess_set "too_many_mailfroms" "yes";
                        }
                    }
                }
            }
            else {
                $offnet_auth_id = vctx_conn_get "auth_identity";
                ec_gauge_cache_init "relay_offnet_hour_count_list" 25000 3600 1;
                ec_gauge_cache_init "relay_offnet_hour_block_list" 25000 3600 1;
                # If an smtp auth user sends more messages than the mailfrom_threshold disconnect else incriment the hour count list.
                $block_offnet_test = ec_gauge_cache_get "relay_offnet_hour_block_list" "${offnet_auth_id}";
                if ec_test :value "gt" :comparator "i;ascii-numeric" "${block_offnet_test}" "0"{
                    if not ec_test :is "${as_wl}" "true" {
                        audit_series_add $ob_rejections;
                        audit_series_add $ob_rejections;
                    }
                    ec_disconnect 452 "4.7.0 [F11-1] Too many messages sent.";
                }
                else {
                    ec_gauge_cache_inc "relay_offnet_hour_count_list" "${offnet_auth_id}";
                    # If the hour_count_list is above the mailfrom_threshold add to the hour_block_list
                    $hour_offnet_count_test = ec_gauge_cache_get "relay_offnet_hour_count_list" "${offnet_auth_id}";
                    if ec_test :value "gt" :comparator "i;ascii-numeric" "${hour_offnet_count_test}" "${smtp_offnet_threshold}" {
                        ec_gauge_cache_inc "relay_offnet_hour_block_list" "${offnet_auth_id}";
                        vctx_mess_set "too_many_mailfroms" "yes";
                    }
                }
            }
        }
    }
}                

# Check to see if mail from domain exists
# this relies on the spf module being loaded to work
if not ec_test :regex :comparator "i;ascii-casemap" "%{vctx_mess:mailfrom_domain}" "\.int$" {
    if vctx :is "mailfrom_domain_status" "nxdomain" {
        if not ec_test :is "${as_wl}" "true" {
            if vctx_conn :is "mx" "true" {
                audit_series_add $ib_rejections;
                audit_series_add $ib_envelope_violations;
            }
            else {
                audit_series_add $ob_rejections;
                audit_series_add $ob_envelope_violations;
            }
        }
	    ec_action 550 "5.1.7 [F16] No such domain ${from_domain}." "spoof:Fraudulent sender";
	    stop;
    }
}

# As_logger count messages
if not vctx :is "as_wl" "true" {
    if vctx_conn :is "mx" "true" {
        audit_series_add $ib_message_vol;
    }
    else {
        audit_series_add $ob_message_vol;
    }
}    
